---
title: "04_homework2"
author: "Randy"
date: "2/4/2021"
output:
  word_document: 
    reference_docx: template.docx
---
# BIOS7721 Homework2

```{r package, include=FALSE}
## packages for data manipulation
library(tidyverse)
library(janitor)
library(magrittr)

## packages for graphs and plots
library(ggplot2)
library(ggfortify)

## packages for survival
library(survminer)
library(survival)
library(JM)

## packages for lmm
library(nlme)

## packages for bootstrap
library(boot)

## packages for regression and tables
library(broom)
library(gtsummary)
library(here)

## software information
sessionInfo()
R.Version()
```

```{r setup, include=FALSE}
## package_name::function_name
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE)
```

## Introduction
* dataset contains 500 patients
* human tissue valve in aortic position
* subcoronary implantation (SI) or root replacement (RR)
* followed over time and longitudinal aortic gradient measurements 
* at risk of experiencing death following their surgery
```{r}
aort <- here::here("aort_new.csv") %>% 
  read_csv() %>%
  janitor::clean_names() 

## aort data is in longitudial form
## each row is for one visit
## one subject has many visit
# View(aort)
```

## Question1. Survival analysis with a time-varying covariate

### a. create the start/stop time data set
* the beginning of a time interval represents a measurement time
* the end of the final time window represents the survival time
* You also need a new status indicator 
* indicator value of 0 for all intervals 
* the last indicator is 1 if an event is observed
* the last indicator is 0 if a patient is censored
* print the rows for Patients 1 and 2.
```{r}
aort1 <- aort %>%
  ## tmerge cannot bear duplicate id
  filter(time == 0) %>%
  ## time based merge for survial data
  survival::tmerge(
    data1 = .,
    data2 = .,
    id = id, 
    ## the tdc and event use 
    ## the final value in the data
    ## 4 types of operational arguments:
    ## tdc/cumtdc/event/cumevent
    death = event(survtime, event)) %>%
  ## start stop death added
  survival::tmerge(
    data1 = .,
    data2 = aort,
    id = id,
    sqrt_aort_grad = tdc(time, sqrt(aort_grad))) %>%
  ## given time, sqrt_aort_grad added
  select(id, tstart, 
         tstop, death, 
         sqrt_aort_grad, 
         oper, sex)

aort1 %>%
  filter(id %in% c(1,2)) %>%
  knitr::kable("simple", align = "c")

```

\newpage

### b. for patient 3 create a stepped line plot 
* square root aortic gradient
* vertical dashed line for patient's observed survival time
```{r fig.height=3, fig.width=6}
aort1_id3 <- aort1 %>%
  filter(id == 3) 

plot_id3 <- aort1_id3 %>%
  ggplot(aes(tstart, sqrt_aort_grad)) +
  geom_step(direction = "hv",
            size = 1) +
  geom_point(color = "darkred",
             shape = "*",
             size = 7) +
  geom_vline(xintercept = max(aort1_id3$tstop),
             linetype = "dashed",
             color = "brown",
             size = 1) +
  theme_classic2() +
  xlab("Time/year") +
  ylab("sqrt(aortic gradient)")

plot_id3
```

\newpage

### c. fit an extended Cox survival model 
* square root aortic gradient as a time-varying covariate
* operation type and sex as a time-independent baseline covariate
* interpret the coefficient estimates
* how it is the different from model with only the baseline values?

\break
The aortic gradient level can significantly affect 
the subject's survival status (p << 0.001).
On average, one unit increase on the sqrt of aortic gradient 
can increase the risk of event to 1.5 folds (95% CI 1.39 1.62).\
After adjusted for the biomarker aortic gradient, 
the effect of operation type on survival becomes on significant, 
and effect size exp(operation) changes from 0.95 fold to 0.67; 
given patient's aort gradient level, operation SI has stronger effects
on survival improvement for certain patient.\
Also the adjustment of biomarker revert the effect of gender, 
from increasing risk of event to decreasing risk of event, 
even though neither of model show these gender effects significant.\
Overall the model performance gets improved in model cox1 (AIC = 2284);
the AIC decreased, comparing to the baseline value model cox0 (AIC = 2400).
```{r}
## add the survobj into aort1 as part of dataset
aort1$survobj <- with(aort1, Surv(tstart, tstop, death))
cox0 <- coxph(survobj ~ oper + sex, 
              data = aort1)
cox1 <- coxph(survobj ~ oper + sex + sqrt_aort_grad, 
              data = aort1)
tidy0 <- tidy(cox0) %>%
  tibble() %>%
  mutate(model = "cox-ex")
tidy1 <- tidy(cox1) %>%
  tibble() %>%
  mutate(model = "cox-ex")
glance0 <- glance(cox0)
glance1 <- glance(cox1)
```
---

```{r}
summary(cox0)
summary(cox1)
```
---

```{r}
rbind(glance0, glance1) %>%
  tibble() %>%
  rownames_to_column("model") %>%
  select(model, AIC, BIC, logLik) %>%
  knitr::kable("simple", align = "c")
```

\newpage

### d. comment on why it is not appropriate of the extended Cox model

The extended Cox model assumptions is only valid 
for exogenous time dependent covariates.
However in this case, the aortic gradient level is a endogenous bio-marker, 
the level of which closely related to failure status. \
The biomarker level cannot be predetermined or totally immune to measurement errors.\ 
Also for extended Cox model, we would assume that 
the aortic gradient changes only at the measurement times and remain constant 
between two measurements, as step-function approximation.\
Therefore, extended Cox model is not appropriate, or at least not the optimal method.

\newpage

## Question2. Two stage model
### a. fit a mixed effects model 
* outcome: square root aortic gradient
* fixed effects: linear time, operation type, and sex
* random effects: intercept and linear slope for time
* interpret the coefficient estimates from this model

```{r}
lme1 <- nlme::lme(sqrt_aort_grad ~ 
                    oper + sex + tstart, 
                  random = (~ 1 + tstart | id),
                  data = aort1)
summary(lme1)
```
As seen in model lme1, time has a very highly significant effect on
the level of aortic gradient level (p << 0.001); 
on average, every year will increase the subject's sqrt aortic gradient level 0.33 unit.
Operation type SI can increase sqrt aortic gradient 0.737 compare to RR.

There is some variability for each patient baseline aortic gradient level sd_(Intercept) = 0.934,
and the random linear time effects sd_slope = 0.175. 
The random intercept and random slope are not strongly related with each other.
We can see that the variability for within individual is still pretty high time to time.


\newpage

### b. the mixed effects model as subject-specific predictions
* the contributions from the random intercept and random slope
* use as a time-varying covariate in a Cox survival model
* Cox model includes operation type and sex as time independent baseline covariates
* interpret the coefficient estimates from this model
```{r}
## why this is subject specific? this is marginal
aort1$sqrt_aort_pred <- c(predict(lme1))

cox2 <- coxph(survobj ~ oper + sex + sqrt_aort_pred,
                data = aort1)
tidy2 <- tidy(cox2) %>%
  tibble() %>%
  mutate(model = "two-time")
glance2 <- glance(cox2)
summary(cox2)
```

\newpage

### c. bootstrap
* compute the standard errors for Cox component of the two-stage model
* the differences from the standard errors estimated in the model2? 
* reasons of differences between two methods for inference?

For two-stage model, the estimates are obtained by fitting the corresponding mixed model using the observed responses up to given time from all subjects still at risk. 
Hence, there will be a bias for the implementation that remove all the measurement errors for unbiased predictors, which produce biased results by empirical Bayesian estimates from random effects. The partial likelihood asymptotic feature will no hold anymore. Hence the bootstrapping results have smaller standard errors and confidence interval.

```{r message=FALSE, warning=FALSE}
set.seed(555)

#' get_coef() to extract the coef from one bootstrap
#'
#' @param data the dataset for bootstrap
#' @param indices a placeholder for the map function
#' @return the coefs from the model fitting
#' @examples
#' get_coef(aort1, 1)
get_coef <- function(data, indices) {
  data1 <- data %>%
    group_by(id) %>%
    nest() %>%
    as.data.frame() 
  index <- sample(1:nrow(data1), 
                  size = nrow(data1), 
                  replace =TRUE)
  data2 <- data1[index, ] %>%
    unnest()
  lmm <- lme(sqrt_aort_grad ~ 
               oper + sex + tstart, 
             random = (~ 1 + tstart | id),
             data = data2)
  data2$sqrt_aort_pred <- c(predict(lmm))
  fit1 <- coxph(survobj ~ 
                  oper + sex + sqrt_aort_pred, 
               data = data2)
  return(coef(fit1))
}

## bootstrapping takes too long time
## load .Rdata file to see the result directly
# cox_boot <- 
#   ## repeat 1000 times coxph
#   map_df(.x = 1:1000, 
#          .f = ~get_coef(
#            data = aort1,
#            indices = .x))
#            
# save(cox_boot, file = "cox_boot_20210207.Rdata")

## upload the .Rdata for convinence
load("cox_boot_20210207.Rdata")
```
---

```{r}
tidy(cox2) %>%
  mutate(boot.estimate = as.numeric(map(cox_boot, mean)),
         boot.std.error = as.numeric(map(cox_boot, sd))) %>%
  select(term, estimate, boot.estimate,
         std.error, boot.std.error) %>%
  knitr::kable()
```

```{r eval=FALSE, include=FALSE}
## old bootstrapping code
## use boot::boot function
## not sure how it works
# cox_boots <- 
#   boot::boot(
#   data = aort1,
#   statistic = get_coef,
#   R = 1000)
#   
## export the results from boot structure
# get_boot <- function(bootstrap, index) {
#   boot <- boot.ci(bootstrap, 
#                   type = "norm",
#                   index = index)
#   boot <- boot$norm %>%
#     as.data.frame() %>%
#     mutate(coef = as.numeric(boot$t0)) %>%
#     select(coef, -conf, 
#            "lower .95" = V2, 
#            "upper .95" = V3)
# 
#   return(boot)
# }
# 
## extract the final results
# boot1 <- map_df(.x = 1:3, 
#                 ~ get_boot(cox_boots, 
#                 index = .x)) %>%
#   transmute(`2.5 %` = `lower .95`,
#             `97.5 %` = `upper .95`) %>%
#   rownames_to_column("term") %>%
#   mutate(model = "boots") %>%
#   as.data.frame()
#   
# confint(cox2) %>%
#   as.data.frame() %>%
#   mutate(model = "two-time") %>%
#   rownames_to_column("term") %>% View()
#   rbind(boot1) %>%
#   select(model, everything()) %>%
#   arrange(term) %>%
#   knitr::kable("simple", align = "c")
```

\newpage

### d. comparision 
* the two-stage model and the time-varying covariate model 
* comment on any differences 
* why these differences may exist

Overall these two models are pretty similar to each other. Comparatively, the two-stage model has smaller estimate value and larger standard error. 

The Cox extended model use step function approximation for the time dependent covariate,
which measured without error. This may introduce bias to the estimates and standard error.\
These difference demonstrate the attenuation in the regression coefficients of the cox analysis due to the meansurement error.

```{r}
rbind(tidy1, tidy2) %>%
  select(model, everything()) %>%
  arrange(term) %>%
  knitr::kable("simple", align = "c")
  
```



